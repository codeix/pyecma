#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import graken, Parser
from grako.exceptions import *  # noqa


__version__ = '2014.08.15.12.33.04.04'

__all__ = [
    'EcmaParser',
    'EcmaSemanticParser',
    'EcmaSemantics',
    'main'
]


class EcmaParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=True,
        **kwargs):
        super(EcmaParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            **kwargs
        )

    @graken()
    def _K_BREAK_(self):
        with self._group():
            self._pattern(r'break')

    @graken()
    def _K_DO_(self):
        with self._group():
            self._pattern(r'do')

    @graken()
    def _K_INSTANCEOF_(self):
        with self._group():
            self._pattern(r'instanceof')

    @graken()
    def _K_TYPEOF_(self):
        with self._group():
            self._pattern(r'typeof')

    @graken()
    def _K_CASE_(self):
        with self._group():
            self._pattern(r'case')

    @graken()
    def _K_ELSE_(self):
        with self._group():
            self._pattern(r'else')

    @graken()
    def _K_NEW_(self):
        with self._group():
            self._pattern(r'new')

    @graken()
    def _K_VAR_(self):
        with self._group():
            self._pattern(r'var')

    @graken()
    def _K_CATCH_(self):
        with self._group():
            self._pattern(r'catch')

    @graken()
    def _K_FINALLLY_(self):
        with self._group():
            self._pattern(r'finally')

    @graken()
    def _K_RETURN_(self):
        with self._group():
            self._pattern(r'return')

    @graken()
    def _K_VOID_(self):
        with self._group():
            self._pattern(r'void')

    @graken()
    def _K_CONTINUE_(self):
        with self._group():
            self._pattern(r'continue')

    @graken()
    def _K_FOR_(self):
        with self._group():
            self._pattern(r'for')

    @graken()
    def _K_SWITCH_(self):
        with self._group():
            self._pattern(r'switch')

    @graken()
    def _K_WHILE_(self):
        with self._group():
            self._pattern(r'while')

    @graken()
    def _K_DEBUGGER_(self):
        with self._group():
            self._pattern(r'debugger')

    @graken()
    def _K_FUNCTION_(self):
        with self._group():
            self._pattern(r'function')

    @graken()
    def _K_THIS_(self):
        with self._group():
            self._pattern(r'this')

    @graken()
    def _K_WITH_(self):
        with self._group():
            self._pattern(r'with')

    @graken()
    def _K_DEFAULT_(self):
        with self._group():
            self._pattern(r'default')

    @graken()
    def _K_IF_(self):
        with self._group():
            self._pattern(r'if')

    @graken()
    def _K_THROW_(self):
        with self._group():
            self._pattern(r'throw')

    @graken()
    def _K_DELETE_(self):
        with self._group():
            self._pattern(r'delete')

    @graken()
    def _K_IN_(self):
        with self._group():
            self._pattern(r'in')

    @graken()
    def _K_TRY_(self):
        with self._group():
            self._pattern(r'try')

    @graken()
    def _K_TRUE_(self):
        with self._group():
            self._pattern(r'true')

    @graken()
    def _K_FALSE_(self):
        with self._group():
            self._pattern(r'false')

    @graken()
    def _K_ALL_(self):
        with self._choice():
            with self._option():
                self._K_BREAK_()
            with self._option():
                self._K_DO_()
            with self._option():
                self._K_INSTANCEOF_()
            with self._option():
                self._K_TYPEOF_()
            with self._option():
                self._K_CASE_()
            with self._option():
                self._K_ELSE_()
            with self._option():
                self._K_NEW_()
            with self._option():
                self._K_VAR_()
            with self._option():
                self._K_CATCH_()
            with self._option():
                self._K_FINALLLY_()
            with self._option():
                self._K_RETURN_()
            with self._option():
                self._K_VOID_()
            with self._option():
                self._K_CONTINUE_()
            with self._option():
                self._K_FOR_()
            with self._option():
                self._K_SWITCH_()
            with self._option():
                self._K_WHILE_()
            with self._option():
                self._K_DEBUGGER_()
            with self._option():
                self._K_FUNCTION_()
            with self._option():
                self._K_THIS_()
            with self._option():
                self._K_WITH_()
            with self._option():
                self._K_DEFAULT_()
            with self._option():
                self._K_IF_()
            with self._option():
                self._K_THROW_()
            with self._option():
                self._K_DELETE_()
            with self._option():
                self._K_IN_()
            with self._option():
                self._K_TRY_()
            with self._option():
                self._K_TRUE_()
            with self._option():
                self._K_FALSE_()
            self._error('no available options')

    @graken()
    def _P_SCB_(self):
        with self._group():
            self._pattern(r'\{')

    @graken()
    def _P_ECB_(self):
        with self._group():
            self._pattern(r'\}')

    @graken()
    def _P_S_FUNC_DELI_(self):
        with self._group():
            self._pattern(r'\(')

    @graken()
    def _P_E_FUNC_DELI_(self):
        with self._group():
            self._pattern(r'\)')

    @graken()
    def _P_S_ARRAY_DELI_(self):
        with self._group():
            self._pattern(r'\[')

    @graken()
    def _P_E_ARRAY_DELI_(self):
        with self._group():
            self._pattern(r'\]')

    @graken()
    def _P_ACCESSOR_(self):
        with self._group():
            self._pattern(r'\.')

    @graken()
    def _P_STAT_TERMINATOR_(self):
        with self._group():
            self._pattern(r';')

    @graken()
    def _P_ARGS_DELIMITER_(self):
        with self._group():
            self._pattern(r',')

    @graken()
    def _P_LT_(self):
        with self._group():
            self._pattern(r'<')

    @graken()
    def _P_GT_(self):
        with self._group():
            self._pattern(r'>')

    @graken()
    def _P_LTE_(self):
        with self._group():
            self._pattern(r'<=')

    @graken()
    def _P_GTE_(self):
        with self._group():
            self._pattern(r'>=')

    @graken()
    def _P_EQUAL_(self):
        with self._group():
            self._pattern(r'==')

    @graken()
    def _P_NOT_EQUAL_(self):
        with self._group():
            self._pattern(r'!=')

    @graken()
    def _P_E_EQUAL_(self):
        with self._group():
            self._pattern(r'===')

    @graken()
    def _P_E_NOT_EQUAL_(self):
        with self._group():
            self._pattern(r'!==')

    @graken()
    def _P_PLUS_(self):
        with self._group():
            self._pattern(r'\+')

    @graken()
    def _P_MINUS_(self):
        with self._group():
            self._pattern(r'-')

    @graken()
    def _P_MULTIPLY_(self):
        with self._group():
            self._pattern(r'\*')

    @graken()
    def _P_DIVIDE_(self):
        with self._group():
            self._pattern(r'\/')

    @graken()
    def _P_MODULO_(self):
        with self._group():
            self._pattern(r'%')

    @graken()
    def _P_PLUS_INC_(self):
        with self._group():
            self._pattern(r'\+\+')

    @graken()
    def _P_MINUS_INC_(self):
        with self._group():
            self._pattern(r'--')

    @graken()
    def _P_BITWISE_LEFT_(self):
        with self._group():
            self._pattern(r'<<')

    @graken()
    def _P_BITWISE_RIGHT_(self):
        with self._group():
            self._pattern(r'>>')

    @graken()
    def _P_BITWISE_RIGHT_UNSIG_(self):
        with self._group():
            self._pattern(r'>>>')

    @graken()
    def _P_BITWISE_AND_(self):
        with self._group():
            self._pattern(r'&')

    @graken()
    def _P_BITWISE_OR_(self):
        with self._group():
            self._pattern(r'\|')

    @graken()
    def _P_BITWISE_XOR_(self):
        with self._group():
            self._pattern(r'\^')

    @graken()
    def _P_NOT_(self):
        with self._group():
            self._pattern(r'!')

    @graken()
    def _P_BITWISE_NOT_(self):
        with self._group():
            self._pattern(r'~')

    @graken()
    def _P_AND_(self):
        with self._group():
            self._pattern(r'&&')

    @graken()
    def _P_OR_(self):
        with self._group():
            self._pattern(r'\|\|')

    @graken()
    def _P_CONDITIONAL_OP_(self):
        with self._group():
            self._pattern(r'\(?')

    @graken()
    def _P_PART_CONDITIONAL_OP_(self):
        with self._group():
            self._pattern(r':')

    @graken()
    def _P_ASSIGN_(self):
        with self._group():
            self._pattern(r'=')

    @graken()
    def _P_ASSIGN_PLUS_(self):
        with self._group():
            self._pattern(r'\+=')

    @graken()
    def _P_ASSIGN_MINUS_(self):
        with self._group():
            self._pattern(r'-=')

    @graken()
    def _P_ASSIGN_MULTIPLY_(self):
        with self._group():
            self._pattern(r'\*=')

    @graken()
    def _P_ASSIGN_DIVIDE_(self):
        with self._group():
            self._pattern(r'\/=')

    @graken()
    def _P_ASSIGN_MODULO_(self):
        with self._group():
            self._pattern(r'%=')

    @graken()
    def _P_ASSIGN_BITWISE_LEFT_(self):
        with self._group():
            self._pattern(r'<<=')

    @graken()
    def _P_ASSIGN_BITWISE_RIGHT_(self):
        with self._group():
            self._pattern(r'>>=')

    @graken()
    def _P_ASSIGN_BITWISE_RIGHT_UNSIG_(self):
        with self._group():
            self._pattern(r'>>>=')

    @graken()
    def _P_ASSIGN_BITWISE_AND_(self):
        with self._group():
            self._pattern(r'&=')

    @graken()
    def _P_ASSIGN_BITWISE_OR_(self):
        with self._group():
            self._pattern(r'\|=')

    @graken()
    def _P_ASSIGN_BITWISE_XOR_(self):
        with self._group():
            self._pattern(r'\^=')

    @graken()
    def _P_ALL_(self):
        with self._choice():
            with self._option():
                self._P_SCB_()
            with self._option():
                self._P_ECB_()
            with self._option():
                self._P_S_FUNC_DELI_()
            with self._option():
                self._P_E_FUNC_DELI_()
            with self._option():
                self._P_S_ARRAY_DELI_()
            with self._option():
                self._P_E_ARRAY_DELI_()
            with self._option():
                self._P_ACCESSOR_()
            with self._option():
                self._P_STAT_TERMINATOR_()
            with self._option():
                self._P_ARGS_DELIMITER_()
            with self._option():
                self._P_LT_()
            with self._option():
                self._P_GT_()
            with self._option():
                self._P_LTE_()
            with self._option():
                self._P_GTE_()
            with self._option():
                self._P_EQUAL_()
            with self._option():
                self._P_NOT_EQUAL_()
            with self._option():
                self._P_E_EQUAL_()
            with self._option():
                self._P_E_NOT_EQUAL_()
            with self._option():
                self._P_PLUS_()
            with self._option():
                self._P_MINUS_()
            with self._option():
                self._P_MULTIPLY_()
            with self._option():
                self._P_DIVIDE_()
            with self._option():
                self._P_MODULO_()
            with self._option():
                self._P_PLUS_INC_()
            with self._option():
                self._P_MINUS_INC_()
            with self._option():
                self._P_BITWISE_LEFT_()
            with self._option():
                self._P_BITWISE_RIGHT_()
            with self._option():
                self._P_BITWISE_RIGHT_UNSIG_()
            with self._option():
                self._P_BITWISE_AND_()
            with self._option():
                self._P_BITWISE_OR_()
            with self._option():
                self._P_BITWISE_XOR_()
            with self._option():
                self._P_NOT_()
            with self._option():
                self._P_BITWISE_NOT_()
            with self._option():
                self._P_AND_()
            with self._option():
                self._P_OR_()
            with self._option():
                self._P_CONDITIONAL_OP_()
                self._P_PART_CONDITIONAL_OP_()
            with self._option():
                self._P_ASSIGN_()
            with self._option():
                self._P_ASSIGN_PLUS_()
            with self._option():
                self._P_ASSIGN_MINUS_()
            with self._option():
                self._P_ASSIGN_MULTIPLY_()
            with self._option():
                self._P_ASSIGN_DIVIDE_()
            with self._option():
                self._P_ASSIGN_MODULO_()
            with self._option():
                self._P_ASSIGN_BITWISE_LEFT_()
            with self._option():
                self._P_ASSIGN_BITWISE_RIGHT_()
            with self._option():
                self._P_ASSIGN_BITWISE_RIGHT_UNSIG_()
            with self._option():
                self._P_ASSIGN_BITWISE_AND_()
                self._P_ASSIGN_BITWISE_OR_()
            with self._option():
                self._P_ASSIGN_BITWISE_XOR_()
            self._error('no available options')

    @graken()
    def _L_WS_(self):
        self._pattern(r'(?:\s+)')

    @graken()
    def _L_VARIABLE_REG_(self):
        self._pattern(r'((?:[^\W0-9]+[0-9]*)+)')

    @graken()
    def _L_VARIABLE_(self):
        with self._ifnot():
            with self._group():
                self._K_ALL_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._L_WS_()
                        with self._option():
                            self._P_ALL_()
                        self._error('no available options')
        self._L_VARIABLE_REG_()

    @graken()
    def _P_S_OPER_DELI_(self):
        with self._group():
            self._pattern(r'\(')

    @graken()
    def _P_E_OPER_DELI_(self):
        with self._group():
            self._pattern(r'\)')

    @graken()
    def _T_NUMBER_(self):
        self._pattern(r'[\+-]?[0-9]+(?:\.[0-9]*)?(?:[eE][-\+]?[0-9])?')

    @graken()
    def _T_UNDEFINED_(self):
        self._pattern(r'undefined')

    @graken()
    def _T_NULL_(self):
        self._pattern(r'null')

    @graken()
    def _T_BOOL_(self):
        with self._choice():
            with self._option():
                self._K_TRUE_()
            with self._option():
                self._K_FALSE_()
            self._error('no available options')

    @graken()
    def _T_STRING_(self):
        with self._choice():
            with self._option():
                self._pattern(r'"(?:\\"|[^";])*"')
            with self._option():
                self._pattern(r"'(?:\\'|[^';])*'")
            self._error('expecting one of: "(?:\\\\"|[^";])*" \'(?:\\\\\'|[^\';])*\'')

    @graken()
    def _OPERATORS_(self):
        with self._choice():
            with self._option():
                self._P_MINUS_()
            with self._option():
                self._P_PLUS_()
            with self._option():
                self._P_MULTIPLY_()
            with self._option():
                self._P_MODULO_()
            with self._option():
                self._P_DIVIDE_()
            with self._option():
                self._P_BITWISE_LEFT_()
            with self._option():
                self._P_BITWISE_RIGHT_()
            with self._option():
                self._P_BITWISE_RIGHT_UNSIG_()
            self._error('no available options')

    @graken()
    def _ASSIGN_OPERATORS_(self):
        with self._choice():
            with self._option():
                self._P_ASSIGN_()
            with self._option():
                self._P_ASSIGN_PLUS_()
            with self._option():
                self._P_ASSIGN_MINUS_()
            with self._option():
                self._P_ASSIGN_MULTIPLY_()
            with self._option():
                self._P_ASSIGN_DIVIDE_()
            with self._option():
                self._P_ASSIGN_MODULO_()
            with self._option():
                self._P_ASSIGN_BITWISE_LEFT_()
            with self._option():
                self._P_ASSIGN_BITWISE_RIGHT_()
            with self._option():
                self._P_ASSIGN_BITWISE_RIGHT_UNSIG_()
            with self._option():
                self._P_ASSIGN_BITWISE_AND_()
            with self._option():
                self._P_ASSIGN_BITWISE_OR_()
            with self._option():
                self._P_ASSIGN_BITWISE_XOR_()
            self._error('no available options')

    @graken()
    def _CREMENT_OPERATORS_(self):
        with self._choice():
            with self._option():
                self._P_PLUS_INC_()
            with self._option():
                self._P_MINUS_INC_()
            self._error('no available options')

    @graken()
    def _COMPARE_OPERATORS_(self):
        with self._choice():
            with self._option():
                self._P_LTE_()
            with self._option():
                self._P_GTE_()
            with self._option():
                self._P_LT_()
            with self._option():
                self._P_GT_()
            with self._option():
                self._P_EQUAL_()
            with self._option():
                self._P_NOT_EQUAL_()
            with self._option():
                self._P_E_EQUAL_()
            with self._option():
                self._P_E_NOT_EQUAL_()
            self._error('no available options')

    @graken()
    def _TYPES_(self):
        with self._choice():
            with self._option():
                self._T_NUMBER_()
            with self._option():
                self._T_UNDEFINED_()
            with self._option():
                self._T_NULL_()
            with self._option():
                self._T_BOOL_()
            with self._option():
                self._T_STRING_()
            with self._option():
                self._L_VARIABLE_()
            with self._option():
                self._OBJECTTYPES_()
            self._error('no available options')

    @graken()
    def _OBJECTTYPES_(self):
        with self._choice():
            with self._option():
                self._object_()
            with self._option():
                self._array_()
            self._error('no available options')

    @graken()
    def _expression_(self):
        self._calculation_()
        self.ast['cal'] = self.last_node

        def block2():
            self._compare_()
        self._closure(block2)
        self.ast['comp'] = self.last_node

        self.ast._define(
            ['cal', 'comp'],
            []
        )

    @graken()
    def _compare_(self):
        with self._optional():
            self._L_WS_()
        self._COMPARE_OPERATORS_()
        self.ast['op'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._calculation_()
        self.ast['cal'] = self.last_node
        with self._optional():
            self._L_WS_()

        self.ast._define(
            ['op', 'cal'],
            []
        )

    @graken()
    def _calculation_(self):
        self._term_()
        self._cut()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._P_PLUS_()
                        self._cut()
                        self._term_()
                with self._option():
                    with self._group():
                        self._P_MINUS_()
                        self._cut()
                        self._term_()
                self._error('no available options')
        self._closure(block0)

    @graken()
    def _factor_(self):
        with self._choice():
            with self._option():
                with self._optional():
                    self._L_WS_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._accessible_()
                        with self._option():
                            self._increment_()
                        with self._option():
                            self._callable_()
                        with self._option():
                            self._TYPES_()
                        self._error('no available options')
                with self._optional():
                    self._L_WS_()
            with self._option():
                self._group_()
            self._error('no available options')

    @graken()
    def _term_(self):
        self._factor_()
        self._cut()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        self._P_MULTIPLY_()
                        self._cut()
                        self._factor_()
                with self._option():
                    with self._group():
                        self._P_DIVIDE_()
                        self._cut()
                        self._factor_()
                self._error('no available options')
        self._closure(block0)

    @graken()
    def _group_(self):
        with self._optional():
            self._L_WS_()
        self._P_S_OPER_DELI_()
        self._cut()
        self._expression_()
        self._cut()
        self._P_E_OPER_DELI_()
        with self._optional():
            self._L_WS_()

    @graken()
    def _program_(self):

        def block0():
            self._program_basics_()
        self._closure(block0)

    @graken()
    def _program_basics_(self):
        with self._choice():
            with self._option():
                self._switchstatement_()
            with self._option():
                self._forstatement_()
            with self._option():
                self._ifstatement_()
            with self._option():
                self._whilestatement_()
            with self._option():
                self._dowhilestatement_()
            with self._option():
                self._function_()
            with self._option():
                self._statement_()
            self._error('no available options')

    @graken()
    def _program_common_(self):
        with self._choice():
            with self._option():
                self._continue_statement_()
            with self._option():
                self._break_statement_()
            with self._option():
                self._return_statement_()
            with self._option():
                self._program_basics_()
            self._error('no available options')

    @graken()
    def _assign_(self):
        self._assign_embed_()
        with self._optional():
            self._L_WS_()
        self._P_STAT_TERMINATOR_()

    @graken()
    def _assign_embed_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_create_()
                with self._option():
                    self._variable_set_()
                self._error('no available options')
        self.ast['var'] = self.last_node
        with self._optional():
            self._L_WS_()
        with self._group():
            self._ASSIGN_OPERATORS_()
        self.ast['oper'] = self.last_node
        with self._group():
            self._expression_()
        self.ast['ex'] = self.last_node

        self.ast._define(
            ['var', 'oper', 'ex'],
            []
        )

    @graken()
    def _statement_(self):
        with self._choice():
            with self._option():
                self._assign_()
            with self._option():
                with self._group():
                    self._expression_()
                    with self._optional():
                        self._L_WS_()
                    self._P_STAT_TERMINATOR_()
            self._error('no available options')

    @graken()
    def _statement_embed_(self):
        with self._choice():
            with self._option():
                self._assign_()
            with self._option():
                self._expression_()
            self._error('no available options')

    @graken()
    def _variable_create_(self):
        self._K_VAR_()
        self._L_WS_()
        self._L_VARIABLE_()
        with self._optional():
            self._L_WS_()

    @graken()
    def _variable_set_(self):
        self._L_VARIABLE_()
        with self._optional():
            self._L_WS_()

    @graken()
    def _increment_(self):
        with self._choice():
            with self._option():
                self._pre_increment_()
            with self._option():
                self._post_increment_()
            self._error('no available options')

    @graken()
    def _pre_increment_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._P_PLUS_INC_()
                with self._option():
                    self._P_MINUS_INC_()
                self._error('no available options')
        self.ast['oper'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._L_VARIABLE_()
        self.ast['var'] = self.last_node

        self.ast._define(
            ['oper', 'var'],
            []
        )

    @graken()
    def _post_increment_(self):
        self._L_VARIABLE_()
        self.ast['var'] = self.last_node
        with self._optional():
            self._L_WS_()
        with self._group():
            with self._choice():
                with self._option():
                    self._P_PLUS_INC_()
                with self._option():
                    self._P_MINUS_INC_()
                self._error('no available options')
        self.ast['oper'] = self.last_node

        self.ast._define(
            ['var', 'oper'],
            []
        )

    @graken()
    def _code_block_(self):
        self._P_SCB_()
        with self._optional():
            self._L_WS_()

        def block0():
            self._program_common_()
        self._closure(block0)
        with self._optional():
            self._L_WS_()
        self._P_ECB_()

    @graken()
    def _return_statement_(self):
        self._K_RETURN_()
        with self._optional():
            self._L_WS_()
        with self._group():
            self._expression_()
            self.ast['ex'] = self.last_node
            with self._optional():
                self._L_WS_()
            self._P_STAT_TERMINATOR_()

        self.ast._define(
            ['ex'],
            []
        )

    @graken()
    def _break_statement_(self):
        self._K_BREAK_()
        with self._optional():
            self._L_WS_()
        self._P_STAT_TERMINATOR_()

    @graken()
    def _continue_statement_(self):
        self._K_CONTINUE_()
        with self._optional():
            self._L_WS_()
        self._P_STAT_TERMINATOR_()

    @graken()
    def _arguments_(self):
        with self._group():
            with self._optional():
                self._L_WS_()

            def block0():
                self._L_VARIABLE_()
                with self._optional():
                    self._L_WS_()
                self._P_ARGS_DELIMITER_()
                with self._optional():
                    self._L_WS_()
            self._closure(block0)
            with self._optional():
                self._L_VARIABLE_()
            with self._optional():
                self._L_WS_()

    @graken()
    def _function_(self):
        with self._choice():
            with self._option():
                self._function_classic_()
            with self._option():
                self._function_assign_()
            self._error('no available options')

    @graken()
    def _function_classic_(self):
        self._K_FUNCTION_()
        with self._optional():
            self._L_WS_()
        self._L_VARIABLE_()
        self.ast['name'] = self.last_node
        self._function_body_()
        self.ast['body'] = self.last_node

        self.ast._define(
            ['name', 'body'],
            []
        )

    @graken()
    def _function_assign_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_create_()
                with self._option():
                    self._variable_set_()
                self._error('no available options')
        self.ast['name'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_ASSIGN_()
        with self._optional():
            self._L_WS_()
        self._K_FUNCTION_()
        with self._optional():
            self._L_WS_()
        self._function_body_()
        self.ast['body'] = self.last_node

        self.ast._define(
            ['name', 'body'],
            []
        )

    @graken()
    def _function_body_(self):
        with self._optional():
            self._L_WS_()
        self._P_S_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._arguments_()
        self.ast['sign'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._code_block_()
        self.ast['code'] = self.last_node

        self.ast._define(
            ['sign', 'code'],
            []
        )

    @graken()
    def _parameters_(self):
        with self._group():
            with self._optional():
                self._L_WS_()
            with self._optional():
                self._expression_()
            with self._optional():
                self._L_WS_()

            def block0():
                with self._optional():
                    self._L_WS_()
                self._P_ARGS_DELIMITER_()
                with self._optional():
                    self._L_WS_()
                self._expression_()
                with self._optional():
                    self._L_WS_()
            self._closure(block0)
            with self._optional():
                self._L_WS_()

    @graken()
    def _callable_(self):
        self._L_VARIABLE_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_S_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._parameters_()
        self.ast['params'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_FUNC_DELI_()

        self.ast._define(
            ['name', 'params'],
            []
        )

    @graken()
    def _codesingleline_(self):
        with self._choice():
            with self._option():
                with self._group():
                    self._program_common_()
            with self._option():
                self._code_block_()
            self._error('no available options')

    @graken()
    def _ifstatement_(self):
        self._K_IF_()
        with self._optional():
            self._L_WS_()
        self._P_S_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._expression_()
        self.ast['ex'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._codesingleline_()
        self.ast['if_'] = self.last_node
        with self._optional():
            self._elsestatement_()
        self.ast['else_'] = self.last_node

        self.ast._define(
            ['ex', 'if', 'else'],
            []
        )

    @graken()
    def _elsestatement_(self):
        with self._optional():
            self._L_WS_()
        self._K_ELSE_()
        self._codesingleline_()
        self.ast['else_'] = self.last_node

        self.ast._define(
            ['else'],
            []
        )

    @graken()
    def _whilestatement_(self):
        self._K_WHILE_()
        with self._optional():
            self._L_WS_()
        self._P_S_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._expression_()
        self.ast['ex'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._codesingleline_()
        self.ast['code'] = self.last_node

        self.ast._define(
            ['ex', 'code'],
            []
        )

    @graken()
    def _dowhilestatement_(self):
        self._K_DO_()
        with self._optional():
            self._L_WS_()
        self._code_block_()
        self.ast['code'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._K_WHILE_()
        with self._optional():
            self._L_WS_()
        self._P_S_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._expression_()
        self.ast['ex'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._P_STAT_TERMINATOR_()
        with self._optional():
            self._L_WS_()

        self.ast._define(
            ['code', 'ex'],
            []
        )

    @graken()
    def _forstatement_(self):
        self._K_FOR_()
        with self._optional():
            self._L_WS_()
        self._P_S_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        with self._group():
            with self._choice():
                with self._option():
                    self._P_STAT_TERMINATOR_()
                with self._option():
                    with self._optional():
                        self._statement_embed_()
                    self.ast['var'] = self.last_node
                self._error('no available options')
        with self._optional():
            self._L_WS_()
        with self._optional():
            self._expression_()
        self.ast['cond'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_STAT_TERMINATOR_()
        with self._optional():
            self._L_WS_()
        with self._optional():
            self._statement_embed_()
        self.ast['exp'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._codesingleline_()
        self.ast['code'] = self.last_node

        self.ast._define(
            ['var', 'cond', 'exp', 'code'],
            []
        )

    @graken()
    def _switchstatement_(self):
        self._K_SWITCH_()
        with self._optional():
            self._L_WS_()
        self._P_S_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._expression_()
        self.ast['ex'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_FUNC_DELI_()
        with self._optional():
            self._L_WS_()
        self._P_SCB_()
        with self._optional():
            self._L_WS_()

        def block2():
            with self._choice():
                with self._option():
                    self._switchdefault_()
                with self._option():
                    self._switchcase_()
                self._error('no available options')
        self._closure(block2)
        self.ast['cases'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_ECB_()

        self.ast._define(
            ['ex', 'cases'],
            []
        )

    @graken()
    def _switchcase_(self):
        self._K_CASE_()

        def block0():
            self._L_WS_()
        self._positive_closure(block0)

        self._expression_()
        self.ast['ex'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_PART_CONDITIONAL_OP_()
        self._switchcodeblock_()
        self.ast['code'] = self.last_node

        self.ast._define(
            ['ex', 'code'],
            []
        )

    @graken()
    def _switchdefault_(self):
        self._K_DEFAULT_()
        with self._optional():
            self._L_WS_()
        self._P_PART_CONDITIONAL_OP_()
        self._switchcodeblock_()
        self.ast['code'] = self.last_node

        self.ast._define(
            ['code'],
            []
        )

    @graken()
    def _switchcodeblock_(self):

        def block0():
            self._program_common_()
        self._closure(block0)

    @graken()
    def _array_(self):
        self._P_S_ARRAY_DELI_()
        with self._group():
            with self._optional():
                self._L_WS_()

            def block1():
                self._content_()
                with self._optional():
                    self._L_WS_()
                self._P_ARGS_DELIMITER_()
                with self._optional():
                    self._L_WS_()
            self._closure(block1)
            with self._optional():
                self._content_()
            with self._optional():
                self._L_WS_()
        self.ast['listitems'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_E_ARRAY_DELI_()

        self.ast._define(
            ['listitems'],
            []
        )

    @graken()
    def _object_(self):
        self._P_SCB_()
        with self._optional():
            self._L_WS_()
        with self._group():
            with self._optional():
                self._L_WS_()

            def block1():
                self._objectitem_()
                with self._optional():
                    self._L_WS_()
                self._P_ARGS_DELIMITER_()
                with self._optional():
                    self._L_WS_()
            self._closure(block1)
            with self._optional():
                self._objectitem_()
            with self._optional():
                self._L_WS_()
        self.ast['objectitems'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_ECB_()

        self.ast._define(
            ['objectitems'],
            []
        )

    @graken()
    def _objectitem_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._T_STRING_()
                with self._option():
                    self._L_VARIABLE_()
                self._error('no available options')
        self.ast['key'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._P_PART_CONDITIONAL_OP_()
        with self._optional():
            self._L_WS_()
        self._content_()
        self.ast['value'] = self.last_node
        with self._optional():
            self._L_WS_()

        self.ast._define(
            ['key', 'value'],
            []
        )

    @graken()
    def _content_(self):
        with self._choice():
            with self._option():
                self._array_()
            with self._option():
                self._object_()
            with self._option():
                with self._optional():
                    self._L_WS_()
                self._K_FUNCTION_()
                with self._optional():
                    self._L_WS_()
                self._function_body_()
                with self._optional():
                    self._L_WS_()
            with self._option():
                self._expression_()
            self._error('no available options')

    @graken()
    def _accessible_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._accessible_()
                with self._option():
                    self._TYPES_()
                self._error('no available options')
        self.ast['obj'] = self.last_node
        with self._optional():
            self._L_WS_()
        self._array_()
        self.ast['access'] = self.last_node

        self.ast._define(
            ['obj', 'access'],
            []
        )


class EcmaSemantics(object):
    def K_BREAK(self, ast):
        return ast

    def K_DO(self, ast):
        return ast

    def K_INSTANCEOF(self, ast):
        return ast

    def K_TYPEOF(self, ast):
        return ast

    def K_CASE(self, ast):
        return ast

    def K_ELSE(self, ast):
        return ast

    def K_NEW(self, ast):
        return ast

    def K_VAR(self, ast):
        return ast

    def K_CATCH(self, ast):
        return ast

    def K_FINALLLY(self, ast):
        return ast

    def K_RETURN(self, ast):
        return ast

    def K_VOID(self, ast):
        return ast

    def K_CONTINUE(self, ast):
        return ast

    def K_FOR(self, ast):
        return ast

    def K_SWITCH(self, ast):
        return ast

    def K_WHILE(self, ast):
        return ast

    def K_DEBUGGER(self, ast):
        return ast

    def K_FUNCTION(self, ast):
        return ast

    def K_THIS(self, ast):
        return ast

    def K_WITH(self, ast):
        return ast

    def K_DEFAULT(self, ast):
        return ast

    def K_IF(self, ast):
        return ast

    def K_THROW(self, ast):
        return ast

    def K_DELETE(self, ast):
        return ast

    def K_IN(self, ast):
        return ast

    def K_TRY(self, ast):
        return ast

    def K_TRUE(self, ast):
        return ast

    def K_FALSE(self, ast):
        return ast

    def K_ALL(self, ast):
        return ast

    def P_SCB(self, ast):
        return ast

    def P_ECB(self, ast):
        return ast

    def P_S_FUNC_DELI(self, ast):
        return ast

    def P_E_FUNC_DELI(self, ast):
        return ast

    def P_S_ARRAY_DELI(self, ast):
        return ast

    def P_E_ARRAY_DELI(self, ast):
        return ast

    def P_ACCESSOR(self, ast):
        return ast

    def P_STAT_TERMINATOR(self, ast):
        return ast

    def P_ARGS_DELIMITER(self, ast):
        return ast

    def P_LT(self, ast):
        return ast

    def P_GT(self, ast):
        return ast

    def P_LTE(self, ast):
        return ast

    def P_GTE(self, ast):
        return ast

    def P_EQUAL(self, ast):
        return ast

    def P_NOT_EQUAL(self, ast):
        return ast

    def P_E_EQUAL(self, ast):
        return ast

    def P_E_NOT_EQUAL(self, ast):
        return ast

    def P_PLUS(self, ast):
        return ast

    def P_MINUS(self, ast):
        return ast

    def P_MULTIPLY(self, ast):
        return ast

    def P_DIVIDE(self, ast):
        return ast

    def P_MODULO(self, ast):
        return ast

    def P_PLUS_INC(self, ast):
        return ast

    def P_MINUS_INC(self, ast):
        return ast

    def P_BITWISE_LEFT(self, ast):
        return ast

    def P_BITWISE_RIGHT(self, ast):
        return ast

    def P_BITWISE_RIGHT_UNSIG(self, ast):
        return ast

    def P_BITWISE_AND(self, ast):
        return ast

    def P_BITWISE_OR(self, ast):
        return ast

    def P_BITWISE_XOR(self, ast):
        return ast

    def P_NOT(self, ast):
        return ast

    def P_BITWISE_NOT(self, ast):
        return ast

    def P_AND(self, ast):
        return ast

    def P_OR(self, ast):
        return ast

    def P_CONDITIONAL_OP(self, ast):
        return ast

    def P_PART_CONDITIONAL_OP(self, ast):
        return ast

    def P_ASSIGN(self, ast):
        return ast

    def P_ASSIGN_PLUS(self, ast):
        return ast

    def P_ASSIGN_MINUS(self, ast):
        return ast

    def P_ASSIGN_MULTIPLY(self, ast):
        return ast

    def P_ASSIGN_DIVIDE(self, ast):
        return ast

    def P_ASSIGN_MODULO(self, ast):
        return ast

    def P_ASSIGN_BITWISE_LEFT(self, ast):
        return ast

    def P_ASSIGN_BITWISE_RIGHT(self, ast):
        return ast

    def P_ASSIGN_BITWISE_RIGHT_UNSIG(self, ast):
        return ast

    def P_ASSIGN_BITWISE_AND(self, ast):
        return ast

    def P_ASSIGN_BITWISE_OR(self, ast):
        return ast

    def P_ASSIGN_BITWISE_XOR(self, ast):
        return ast

    def P_ALL(self, ast):
        return ast

    def L_WS(self, ast):
        return ast

    def L_VARIABLE_REG(self, ast):
        return ast

    def L_VARIABLE(self, ast):
        return ast

    def P_S_OPER_DELI(self, ast):
        return ast

    def P_E_OPER_DELI(self, ast):
        return ast

    def T_NUMBER(self, ast):
        return ast

    def T_UNDEFINED(self, ast):
        return ast

    def T_NULL(self, ast):
        return ast

    def T_BOOL(self, ast):
        return ast

    def T_STRING(self, ast):
        return ast

    def OPERATORS(self, ast):
        return ast

    def ASSIGN_OPERATORS(self, ast):
        return ast

    def CREMENT_OPERATORS(self, ast):
        return ast

    def COMPARE_OPERATORS(self, ast):
        return ast

    def TYPES(self, ast):
        return ast

    def OBJECTTYPES(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def compare(self, ast):
        return ast

    def calculation(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def term(self, ast):
        return ast

    def group(self, ast):
        return ast

    def program(self, ast):
        return ast

    def program_basics(self, ast):
        return ast

    def program_common(self, ast):
        return ast

    def assign(self, ast):
        return ast

    def assign_embed(self, ast):
        return ast

    def statement(self, ast):
        return ast

    def statement_embed(self, ast):
        return ast

    def variable_create(self, ast):
        return ast

    def variable_set(self, ast):
        return ast

    def increment(self, ast):
        return ast

    def pre_increment(self, ast):
        return ast

    def post_increment(self, ast):
        return ast

    def code_block(self, ast):
        return ast

    def return_statement(self, ast):
        return ast

    def break_statement(self, ast):
        return ast

    def continue_statement(self, ast):
        return ast

    def arguments(self, ast):
        return ast

    def function(self, ast):
        return ast

    def function_classic(self, ast):
        return ast

    def function_assign(self, ast):
        return ast

    def function_body(self, ast):
        return ast

    def parameters(self, ast):
        return ast

    def callable(self, ast):
        return ast

    def codesingleline(self, ast):
        return ast

    def ifstatement(self, ast):
        return ast

    def elsestatement(self, ast):
        return ast

    def whilestatement(self, ast):
        return ast

    def dowhilestatement(self, ast):
        return ast

    def forstatement(self, ast):
        return ast

    def switchstatement(self, ast):
        return ast

    def switchcase(self, ast):
        return ast

    def switchdefault(self, ast):
        return ast

    def switchcodeblock(self, ast):
        return ast

    def array(self, ast):
        return ast

    def object(self, ast):
        return ast

    def objectitem(self, ast):
        return ast

    def content(self, ast):
        return ast

    def accessible(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = EcmaParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in EcmaParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for Ecma.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(args.file, args.startrule, trace=args.trace, whitespace=args.whitespace)
